{"version":3,"file":"ngx-scrollbar-smooth-scroll.mjs","sources":["../../../projects/ngx-scrollbar/smooth-scroll/src/bezier-easing.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll.default.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll.model.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll-manager.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/smooth-scroll.ts","../../../projects/ngx-scrollbar/smooth-scroll/src/ngx-scrollbar-smooth-scroll.ts"],"sourcesContent":["/**\r\n * https://github.com/gre/bezier-easing\r\n * BezierEasing - use bezier curve for transition easing function\r\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\r\n */\r\n\r\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\r\nconst NEWTON_ITERATIONS: number = 4;\r\nconst NEWTON_MIN_SLOPE: number = 0.001;\r\nconst SUBDIVISION_PRECISION: number = 0.0000001;\r\nconst SUBDIVISION_MAX_ITERATIONS: number = 10;\r\n\r\nconst kSplineTableSize: number = 11;\r\nconst kSampleStepSize: number = 1.0 / (kSplineTableSize - 1.0);\r\n\r\nconst float32ArraySupported: boolean = typeof Float32Array === 'function';\r\n\r\nfunction A(aA1: number, aA2: number): number {\r\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\r\n}\r\n\r\nfunction B(aA1: number, aA2: number): number {\r\n  return 3.0 * aA2 - 6.0 * aA1;\r\n}\r\n\r\nfunction C(aA1: number): number {\r\n  return 3.0 * aA1;\r\n}\r\n\r\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\r\nfunction calcBezier(aT: number, aA1: number, aA2: number): number {\r\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\r\n}\r\n\r\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\r\nfunction getSlope(aT: number, aA1: number, aA2: number): number {\r\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\r\n}\r\n\r\nfunction binarySubdivide(aX: number, aA: number, aB: number, mX1: number, mX2: number) {\r\n  let currentX, currentT, i: number = 0;\r\n  do {\r\n    currentT = aA + (aB - aA) / 2.0;\r\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\r\n    if (currentX > 0.0) {\r\n      aB = currentT;\r\n    } else {\r\n      aA = currentT;\r\n    }\r\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\r\n  return currentT;\r\n}\r\n\r\nfunction newtonRaphsonIterate(aX: number, aGuessT: number, mX1: number, mX2: number): number {\r\n  for (let i: number = 0; i < NEWTON_ITERATIONS; ++i) {\r\n    const currentSlope: number = getSlope(aGuessT, mX1, mX2);\r\n    if (currentSlope === 0.0) {\r\n      return aGuessT;\r\n    }\r\n    const currentX: number = calcBezier(aGuessT, mX1, mX2) - aX;\r\n    aGuessT -= currentX / currentSlope;\r\n  }\r\n  return aGuessT;\r\n}\r\n\r\nfunction LinearEasing(x: number): number {\r\n  return x;\r\n}\r\n\r\nexport default function bezier(mX1: number, mY1: number, mX2: number, mY2: number) {\r\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\r\n    throw new Error('bezier x values must be in [0, 1] range');\r\n  }\r\n\r\n  if (mX1 === mY1 && mX2 === mY2) {\r\n    return LinearEasing;\r\n  }\r\n\r\n  // Precompute samples table\r\n  const sampleValues: number[] | Float32Array = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\r\n  for (let i: number = 0; i < kSplineTableSize; ++i) {\r\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\r\n  }\r\n\r\n  function getTForX(aX: number): number {\r\n    let intervalStart: number = 0.0;\r\n    let currentSample: number = 1;\r\n    const lastSample: number = kSplineTableSize - 1;\r\n\r\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\r\n      intervalStart += kSampleStepSize;\r\n    }\r\n    --currentSample;\r\n\r\n    // Interpolate to provide an initial guess for t\r\n    const dist: number = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\r\n    const guessForT: number = intervalStart + dist * kSampleStepSize;\r\n\r\n    const initialSlope: number = getSlope(guessForT, mX1, mX2);\r\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\r\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\r\n    } else if (initialSlope === 0.0) {\r\n      return guessForT;\r\n    } else {\r\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\r\n    }\r\n  }\r\n\r\n  return function BezierEasing(x: number): number {\r\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\r\n    if (x === 0) {\r\n      return 0;\r\n    }\r\n    if (x === 1) {\r\n      return 1;\r\n    }\r\n    return calcBezier(getTForX(x), mY1, mY2);\r\n  };\r\n}\r\n","import { SmoothScrollToOptions } from './smooth-scroll.model';\r\n\r\nexport const defaultSmoothScrollOptions: SmoothScrollToOptions = {\r\n  duration: 468,\r\n  easing: {\r\n    x1: 0.42,\r\n    y1: 0,\r\n    x2: 0.58,\r\n    y2: 1\r\n  }\r\n};\r\n","import { ElementRef, InjectionToken, Provider } from '@angular/core';\r\nimport { _XAxis, _YAxis } from '@angular/cdk/scrolling';\r\nimport { defaultSmoothScrollOptions } from './smooth-scroll.default';\r\n\r\nexport const SMOOTH_SCROLL_OPTIONS: InjectionToken<SmoothScrollOptions> = new InjectionToken<SmoothScrollOptions>('SMOOTH_SCROLL_OPTIONS', {\r\n  providedIn: 'root',\r\n  factory: () => defaultSmoothScrollOptions\r\n});\r\n\r\nexport function provideSmoothScrollOptions(options: SmoothScrollOptions): Provider[] {\r\n  return [\r\n    {\r\n      provide: SMOOTH_SCROLL_OPTIONS,\r\n      useValue: { ...defaultSmoothScrollOptions, ...options }\r\n    }\r\n  ]\r\n}\r\n\r\n/**\r\n * Interface for an element that can be scrolled smoothly.\r\n */\r\nexport type SmoothScrollElement = Element | ElementRef<Element> | string;\r\n\r\n/**\r\n * Interface for options provided for smooth scrolling.\r\n */\r\nexport type SmoothScrollToOptions = Partial<Pick<_XAxis, keyof _XAxis> & Pick<_YAxis, keyof _YAxis>> & SmoothScrollOptions;\r\n\r\n/**\r\n * Interface for options provided for smooth scrolling to an element.\r\n */\r\nexport type SmoothScrollToElementOptions = SmoothScrollToOptions & { center?: boolean };\r\n\r\nexport interface SmoothScrollStep {\r\n  scrollable: Element;\r\n  startTime: number;\r\n  startX: number;\r\n  startY: number;\r\n  x: number;\r\n  y: number;\r\n  duration: number;\r\n  easing: (k: number) => number;\r\n  currentX?: number;\r\n  currentY?: number;\r\n}\r\n\r\nexport interface SmoothScrollOptions {\r\n  duration?: number;\r\n  easing?: BezierEasingOptions;\r\n}\r\n\r\nexport interface BezierEasingOptions {\r\n  x1: number;\r\n  y1: number;\r\n  x2: number;\r\n  y2: number;\r\n}\r\n","import { Injectable, inject, ElementRef, NgZone } from '@angular/core';\r\nimport { DOCUMENT } from '@angular/common';\r\nimport { coerceElement } from '@angular/cdk/coercion';\r\nimport {\r\n  Observable,\r\n  Subscriber,\r\n  Subject,\r\n  take,\r\n  merge,\r\n  finalize,\r\n  fromEvent,\r\n  switchMap,\r\n  takeUntil,\r\n  takeWhile\r\n} from 'rxjs';\r\nimport BezierEasing from './bezier-easing';\r\nimport {\r\n  SMOOTH_SCROLL_OPTIONS,\r\n  SmoothScrollElement,\r\n  SmoothScrollStep,\r\n  SmoothScrollToElementOptions,\r\n  SmoothScrollOptions,\r\n  SmoothScrollToOptions\r\n} from './smooth-scroll.model';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class SmoothScrollManager {\r\n\r\n  private document: Document = inject(DOCUMENT);\r\n\r\n  private zone: NgZone = inject(NgZone);\r\n\r\n  // Default options\r\n  private readonly _defaultOptions: SmoothScrollOptions = inject(SMOOTH_SCROLL_OPTIONS);\r\n\r\n  // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.\r\n  // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\r\n  // Purpose: If user called a scroll function again on the same element before the scrolls completes,\r\n  // it cancels the ongoing scroll and starts a new one\r\n  private onGoingScrolls: Map<Element, Subject<void>> = new Map<Element, Subject<void>>();\r\n\r\n  /**\r\n   * Timing method\r\n   */\r\n  private get now(): () => number {\r\n    return this.document.defaultView.performance?.now?.bind(this.document.defaultView.performance) || Date.now;\r\n  }\r\n\r\n  /**\r\n   * changes scroll position inside an element\r\n   */\r\n  private scrollElement(el: Element, x: number, y: number): void {\r\n    el.scrollLeft = x;\r\n    el.scrollTop = y;\r\n  }\r\n\r\n  /**\r\n   * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n   */\r\n  private getElement(el: Element | ElementRef | string, parent?: Element): Element {\r\n    if (typeof el === 'string') {\r\n      return (parent || this.document).querySelector(el);\r\n    }\r\n    return coerceElement<Element>(el);\r\n  }\r\n\r\n  /**\r\n   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n   */\r\n  private getScrollDestroyerRef(el: Element): Subject<void> {\r\n    if (this.onGoingScrolls.has(el)) {\r\n      this.onGoingScrolls.get(el).next();\r\n    }\r\n    return this.onGoingScrolls.set(el, new Subject<void>()).get(el);\r\n  }\r\n\r\n  /**\r\n   * A function called recursively that, given a context, steps through scrolling\r\n   */\r\n  private step(context: SmoothScrollStep): Observable<void> {\r\n    return new Observable((subscriber: Subscriber<void>) => {\r\n      let elapsed: number = (this.now() - context.startTime) / context.duration;\r\n\r\n      // avoid elapsed times higher than one\r\n      elapsed = elapsed > 1 ? 1 : elapsed;\r\n\r\n      // apply easing to elapsed time\r\n      const value: number = context.easing(elapsed);\r\n\r\n      context.currentX = context.startX + (context.x - context.startX) * value;\r\n      context.currentY = context.startY + (context.y - context.startY) * value;\r\n\r\n      this.scrollElement(context.scrollable, context.currentX, context.currentY);\r\n      // Proceed to the step\r\n      requestAnimationFrame(() => {\r\n        subscriber.next();\r\n        subscriber.complete();\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Checks if smooth scroll has reached, cleans up the smooth scroll stream\r\n   */\r\n  private isReached(context: SmoothScrollStep, destroyed: Subject<void>): boolean {\r\n    if (context.currentX === context.x && context.currentY === context.y) {\r\n      // IMPORTANT: Destroy the stream when scroll is reached ASAP!\r\n      destroyed.next();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Scroll recursively until coordinates are reached\r\n   * @param context\r\n   * @param destroyed\r\n   */\r\n  scrolling(context: SmoothScrollStep, destroyed: Subject<void>): Observable<void> {\r\n    return this.step(context).pipe(\r\n      // Continue while target coordinates hasn't reached yet\r\n      takeWhile(() => !this.isReached(context, destroyed)),\r\n      switchMap(() => this.scrolling(context, destroyed))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n   */\r\n  private onScrollReached(el: Element, resolve: () => void, destroyed: Subject<void>): void {\r\n    destroyed.complete();\r\n    this.onGoingScrolls.delete(el);\r\n    this.zone.run(() => resolve());\r\n  }\r\n\r\n  /**\r\n   * Terminates an ongoing smooth scroll\r\n   */\r\n  private interrupted(el: Element, destroyed: Subject<void>): Observable<Event | void> {\r\n    return merge(\r\n      fromEvent(el, 'wheel', { passive: true, capture: true }),\r\n      fromEvent(el, 'touchmove', { passive: true, capture: true }),\r\n      destroyed\r\n    ).pipe(take(1));\r\n  }\r\n\r\n  private applyScrollToOptions(el: Element, options: SmoothScrollToOptions): Promise<void> {\r\n    if (!options.duration) {\r\n      this.scrollElement(el, options.left, options.top);\r\n      return Promise.resolve();\r\n    }\r\n\r\n    return new Promise((resolve: () => void) => {\r\n      this.zone.runOutsideAngular(() => {\r\n        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\r\n        const destroyed: Subject<void> = this.getScrollDestroyerRef(el);\r\n\r\n        const context: SmoothScrollStep = {\r\n          scrollable: el,\r\n          startTime: this.now(),\r\n          startX: el.scrollLeft,\r\n          startY: el.scrollTop,\r\n          x: options.left == null ? el.scrollLeft : ~~options.left,\r\n          y: options.top == null ? el.scrollTop : ~~options.top,\r\n          duration: options.duration,\r\n          easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\r\n        };\r\n\r\n        this.scrolling(context, destroyed).pipe(\r\n          // Continue until interrupted by another scroll (new smooth scroll / wheel / touchmove)\r\n          takeUntil(this.interrupted(el, destroyed)),\r\n          // Once finished, clean up the destroyer stream and resolve the promise\r\n          finalize(() => this.onScrollReached(el, resolve, destroyed)),\r\n        ).subscribe();\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n   * left and right always refer to the left and right side of the scrolling container irrespective\r\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n   * in an RTL context.\r\n   * @param scrollable element\r\n   * @param customOptions specified the offsets to scroll to.\r\n   */\r\n  scrollTo(scrollable: SmoothScrollElement, customOptions: SmoothScrollToOptions): Promise<void> {\r\n    const el: Element = this.getElement(scrollable);\r\n    const isRtl: boolean = getComputedStyle(el).direction === 'rtl';\r\n\r\n    const options: SmoothScrollToOptions = {\r\n      ...this._defaultOptions,\r\n      ...customOptions,\r\n      ...{\r\n        // Rewrite start & end offsets as right or left offsets.\r\n        left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,\r\n        right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right\r\n      }\r\n    };\r\n\r\n    // Rewrite the bottom offset as a top offset.\r\n    if (options.bottom != null) {\r\n      options.top = el.scrollHeight - el.clientHeight - options.bottom;\r\n    }\r\n\r\n    // Rewrite the right offset as a left offset.\r\n    if (isRtl) {\r\n      if (options.left != null) {\r\n        options.right = el.scrollWidth - el.clientWidth - options.left;\r\n      }\r\n      options.left = options.right ? -options.right : options.right;\r\n    } else {\r\n      if (options.right != null) {\r\n        options.left = el.scrollWidth - el.clientWidth - options.right;\r\n      }\r\n    }\r\n    return this.applyScrollToOptions(el, options);\r\n  }\r\n\r\n  /**\r\n   * Scroll to element by reference or selector\r\n   */\r\n  scrollToElement(scrollable: SmoothScrollElement, target: SmoothScrollElement, customOptions: SmoothScrollToElementOptions = {}): Promise<void> {\r\n    const scrollableEl: Element = this.getElement(scrollable);\r\n    const targetEl: Element = this.getElement(target, scrollableEl);\r\n    const isRtl: boolean = getComputedStyle(scrollableEl).direction === 'rtl';\r\n\r\n    if (!targetEl || !scrollableEl) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const scrollableRect: DOMRect = scrollableEl.getBoundingClientRect();\r\n    const targetRect: DOMRect = targetEl.getBoundingClientRect();\r\n\r\n    const options: SmoothScrollToOptions = {\r\n      ...this._defaultOptions,\r\n      ...customOptions,\r\n      ...{\r\n        top: targetRect.top + scrollableEl.scrollTop - scrollableRect.top + (customOptions.top || 0),\r\n        // Rewrite start & end offsets as right or left offsets.\r\n        left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,\r\n        right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right\r\n      }\r\n    };\r\n\r\n    if (customOptions.center) {\r\n      // Calculate the center of the container\r\n      const containerCenterX = scrollableRect.left + scrollableRect.width / 2;\r\n      const containerCenterY = scrollableRect.top + scrollableRect.height / 2;\r\n\r\n      // Calculate the target's position relative to the container\r\n      const targetCenterX = targetRect.left + targetRect.width / 2;\r\n      const targetCenterY = targetRect.top + targetRect.height / 2;\r\n\r\n      // Calculate the scroll position to center the target element in the container\r\n      options.left = targetCenterX - containerCenterX + scrollableEl.scrollLeft;\r\n      options.top = targetCenterY - containerCenterY + scrollableEl.scrollTop;\r\n      return this.applyScrollToOptions(scrollableEl, options);\r\n    }\r\n\r\n    if (options.bottom != null) {\r\n      const bottomEdge: number = scrollableRect.height - targetRect.height;\r\n      options.top = targetRect.top + scrollableEl.scrollTop - scrollableRect.top - bottomEdge + (customOptions.bottom || 0);\r\n    }\r\n\r\n    // Rewrite the right offset as a left offset.\r\n    if (isRtl) {\r\n      options.left = targetRect.left - scrollableRect.left + scrollableEl.scrollLeft + (options.left || 0);\r\n      if (options.right != null) {\r\n        options.left = targetRect.right - scrollableRect.left + scrollableEl.scrollLeft - scrollableRect.width + (options.right || 0);\r\n      }\r\n    } else {\r\n      options.left = targetRect.left - scrollableRect.left + scrollableEl.scrollLeft + (options.left || 0);\r\n      if (options.right != null) {\r\n        options.left = targetRect.right - scrollableRect.left + scrollableEl.scrollLeft - scrollableRect.width + (options.right || 0);\r\n      }\r\n    }\r\n\r\n    const computedOptions: SmoothScrollToOptions = {\r\n      top: options.top,\r\n      left: options.left,\r\n      easing: options.easing,\r\n      duration: options.duration\r\n    }\r\n\r\n    return this.applyScrollToOptions(scrollableEl, computedOptions);\r\n  }\r\n}\r\n","import { Directive, ElementRef, inject } from '@angular/core';\r\nimport { SmoothScrollManager } from './smooth-scroll-manager';\r\nimport { SmoothScrollElement, SmoothScrollToElementOptions, SmoothScrollToOptions } from './smooth-scroll.model';\r\n\r\n@Directive({\r\n  standalone: true,\r\n  selector: '[smoothScroll]',\r\n  exportAs: 'smoothScroll'\r\n})\r\nexport class SmoothScroll {\r\n\r\n  private readonly smoothScroll: SmoothScrollManager = inject(SmoothScrollManager);\r\n\r\n  private readonly element: ElementRef<HTMLElement> = inject(ElementRef<HTMLElement>);\r\n\r\n  scrollTo(options: SmoothScrollToOptions): Promise<void> {\r\n    return this.smoothScroll.scrollTo(this.element, options);\r\n  }\r\n\r\n  scrollToElement(target: SmoothScrollElement, options: SmoothScrollToElementOptions): Promise<void> {\r\n    return this.smoothScroll.scrollToElement(this.element, target, options);\r\n  }\r\n}\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["BezierEasing"],"mappings":"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"}